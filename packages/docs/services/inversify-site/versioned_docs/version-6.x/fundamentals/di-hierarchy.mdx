---
sidebar_position: 2
title: DI Hierarchy
---
import diHierarchySource from '@inversifyjs/code-examples/generated/examples/diHierarchy.ts.txt';
import diHierarchyAndCachedBindingsSource from '@inversifyjs/code-examples/generated/examples/v6/diHierarchyAndCachedBindings.ts.txt';

import CodeBlock from '@theme/CodeBlock';

# DI Hierarchy

InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.

With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application.

When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until a binding is found or the top-level parent container is reached.

:::warning[Binding overrides]

Found bindings might override ancestor bindings even if their constraints are not met. For example, if a named binding is found in the child container for the requested service, that binding overrides parent bindings even if this binding is later discarded in a non-named resolution request.

:::

:::warning[DI hierarchies and cached bindings]

When using hierarchical injection, be aware that cached bindings keeps cached values from the first resolution, even if the call comes from a child container.

<CodeBlock language="ts">{diHierarchyAndCachedBindingsSource}</CodeBlock>

:::

By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications.

<CodeBlock language="ts">{diHierarchySource}</CodeBlock>
